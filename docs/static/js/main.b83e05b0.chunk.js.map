{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["CountBombs","grid","x","y","neighbours","i","j","length","push","val","WhoAreMyNeighbours","reduce","prev","curr","GridPiece","number","clicked","index1","index2","shown","isbomb","flagged","flag","onClick","onContextMenu","e","preventDefault","className","style","backgroundColor","EndScreen","state","resetGame","textAlign","position","color","fontSize","top","left","height","App","createGrid","gridStarter","Array","fill","map","Math","floor","random","piece","bombCount","useState","setGrid","UseGrid","setGridPos","resetGrid","flagGridPiece","gameState","setGameState","checkWin","col","key","display","row","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.b83e05b0.chunk.js","sourcesContent":["import React, { useState } from \"react\";\nimport \"./App.css\";\n\nconst WhoAreMyNeighbours = (grid, x, y) => {\n  const neighbours = [];\n  for (let i = x - 1; i <= x + 1; i++) {\n    for (let j = y - 1; j <= y + 1; j++) {\n      if (x === i && y === j) {\n        continue;\n      }\n      if (i >= grid.length || i < 0) {\n        continue;\n      }\n      if (j >= grid[i].length || j < 0) {\n        continue;\n      }\n      neighbours.push({ x: i, y: j, val: grid[i][j].val });\n    }\n  }\n  return neighbours;\n};\n\nconst CountBombs = (grid, x, y) => {\n  const n = WhoAreMyNeighbours(grid, x, y);\n  const ret = n.reduce((prev, curr) => {\n    return prev + curr.val;\n  }, 0);\n  return ret;\n};\n\nconst checkWin = grid => {\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const piece = grid[i][j];\n      if (piece.shown === false && piece.val === 0) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\nconst GridPiece = ({\n  number,\n  clicked,\n  index1,\n  index2,\n  shown,\n  isbomb,\n  flagged,\n  flag\n}) => {\n  return (\n    <div\n      onClick={() => clicked(index1, index2)}\n      onContextMenu={e => {\n        e.preventDefault();\n        flag(index1, index2);\n      }}\n      className=\"gridPiece\"\n      style={{\n        backgroundColor: shown && isbomb ? \"red\" : flagged ? \"yellow\" : \"green\"\n      }}\n    >\n      {shown ? number : null}\n    </div>\n  );\n};\n\nconst UseGrid = () => {\n  const createGrid = () => {\n    const gridStarter = new Array(10).fill(0).map(() =>\n      new Array(15).fill(0).map(() => {\n        return {\n          flagged: false,\n          shown: false,\n          val: Math.floor(Math.random() * 2)\n        };\n      })\n    );\n    return gridStarter.map((grid, i) =>\n      grid.map((piece, j) => {\n        return { ...piece, bombCount: CountBombs(gridStarter, i, j) };\n      })\n    );\n  };\n\n  const [grid, setGrid] = useState(createGrid());\n\n  const setGridPos = (x, y) => {\n    grid[x][y].shown = true;\n    setGrid([...grid]);\n  };\n\n  const flagGridPiece = (x, y) => {\n    grid[x][y].flagged = !grid[x][y].flagged;\n    setGrid([...grid]);\n  };\n\n  const resetGrid = () => setGrid(createGrid());\n  return [grid, setGridPos, resetGrid, flagGridPiece];\n};\n\nconst EndScreen = ({ state, resetGame }) => {\n  return (\n    <div\n      style={{\n        textAlign: \"center\",\n        position: \"absolute\",\n        color: \"red\",\n        fontSize: \"2em\",\n        top: \"5%\",\n        left: \"25%\",\n        height: \"20%\"\n      }}\n    >\n      <h1>{state === \"win\" ? \"You won!\" : \"You lose.\"}</h1>\n      <button onClick={() => resetGame()}>Play Again?</button>\n    </div>\n  );\n};\n\nfunction App() {\n  const [grid, setGridPos, resetGrid, flagGridPiece] = UseGrid();\n  const [gameState, setGameState] = useState(\"\");\n  const clicked = (x, y) => {\n    if (gameState !== \"\") return;\n    setGridPos(x, y);\n    if (grid[x][y].val === 1) {\n      setGameState(\"lose\");\n      return;\n    }\n    if (checkWin(grid)) {\n      setGameState(\"win\");\n    }\n  };\n\n  const resetGame = () => {\n    setGameState(\"\");\n    resetGrid();\n  };\n  return (\n    <div className=\"App\">\n      {gameState !== \"\" ? (\n        <EndScreen gameState={gameState} resetGame={resetGame} />\n      ) : null}\n      {grid.map((col, index1) => (\n        <div key={index1} style={{ display: \"flex\" }}>\n          {col.map((row, index2) => (\n            <GridPiece\n              key={index2}\n              shown={row.shown}\n              number={row.bombCount}\n              isbomb={row.val === 1 ? true : false}\n              index1={index1}\n              index2={index2}\n              clicked={clicked}\n              flagged={row.flagged}\n              flag={flagGridPiece}\n            />\n          ))}\n        </div>\n      ))}\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}